In computer science, in the field of databases, writeâ€“read conflict, also known as reading uncommitted data, is a computational anomaly associated with interleaved execution of transactions.
Given a schedule S

  
    
      
        S
        =
        
          
            [
            
              
                
                  T
                  1
                
                
                  T
                  2
                
              
              
                
                  R
                  (
                  A
                  )
                
                
              
              
                
                  W
                  (
                  A
                  )
                
                
              
              
                
                
                  R
                  (
                  A
                  )
                
              
              
                
                
                  W
                  (
                  A
                  )
                
              
              
                
                
                  R
                  (
                  B
                  )
                
              
              
                
                
                  W
                  (
                  B
                  )
                
              
              
                
                
                  C
                  o
                  m
                  .
                
              
              
                
                  R
                  (
                  B
                  )
                
                
              
              
                
                  W
                  (
                  B
                  )
                
                
              
              
                
                  C
                  o
                  m
                  .
                
                
              
            
            ]
          
        
      
    
    {\displaystyle S={\begin{bmatrix}T1&T2\\R(A)&\\W(A)&\\&R(A)\\&W(A)\\&R(B)\\&W(B)\\&Com.\\R(B)&\\W(B)&\\Com.&\end{bmatrix}}}
  
T2 could read a database object A, modified by T1 which hasn't committed. This is a dirty read.
T1 may write some value into A which makes the database inconsistent. It is possible that interleaved execution can expose this inconsistency and lead to inconsistent final database state, violating ACID rules.
Strict 2PL overcomes this inconsistency by locking T2 out from performing a Read/Write on A. Note however that Strict 2PL can have a number of drawbacks, such as the possibility of deadlocks.
